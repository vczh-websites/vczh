# 术语表（计算机/编译原理）

本表收集 `README.md` 中出现的、与计算机与编译原理相关的术语，并给出简要解释。

## 语法分析与自动机

- **Parser / Parsing（语法分析）**：把 token 序列按文法规则归约为结构化结果（通常是语法树/AST），并在过程中处理递归、优先级、歧义等问题。
- **Lexer（词法分析器）**：把字符流切分为 token（标识符、关键字、符号、数字等）。通常由正则表达式描述 token 模式。
- **Token（记号）**：词法分析阶段的输出单位，携带类型与原始文本/位置信息，是语法分析的输入。
- **Grammar / Rule（文法/产生式）**：描述语言结构的规则集合。文章中一行 `::=` 形式的定义即一条产生式（rule）。
- **EBNF（扩展巴科斯-诺尔范式）**：用于书写文法的记号系统，对 BNF 增加了可选、重复等表达能力。
- **DFA（Deterministic Finite Automaton，确定有限自动机）**：对每个状态与输入字符都有唯一转移的有限状态机；常用于词法分析（正则到自动机）。
- **NFA / ε-NFA（非确定有限自动机 / 含空边的 NFA）**：允许同一输入存在多条转移；ε-NFA 允许不消耗输入的转移（空边），便于表达重复与分支结构。
- **PDA（Pushdown Automaton，下推自动机）**：带栈的状态机，能处理括号匹配、递归结构等上下文无关语言特性，是 LR 系列语法分析的常见抽象。
- **State Machine（状态机）**：以状态与转移描述系统行为的模型。文章把词法/语法的运行过程都落到“状态 + transition”上理解。
- **Transition（状态转移）**：状态机从一个状态到另一个状态的边；在解析器里通常由“看到某个输入”或“完成某个 rule”触发。

## 解析结构与语义动作

- **AST（Abstract Syntax Tree，抽象语法树）**：语法分析的结构化输出，抽象掉部分语法细节，保留后续语义分析/代码生成需要的结构信息。
- **Parse Tree（语法分析树）**：直接反映文法推导过程的树结构；AST 往往是在 parse tree 基础上裁剪/重组得到。
- **Semantic Action（语义动作）**：在语法分析过程中附带执行的动作，用于构造 AST、填充字段、记录歧义信息等。文章中的“指令集”属于一种可生成/可执行的语义动作表示。
- **BeginObject 指令集**：文章中用来构造 AST 的一套抽象指令（BeginObject/EndObject/Field/Token/Discard 等），每个 transition 携带一段指令序列来驱动 AST 构造。
- **Field Assignment（成员赋值）**：把解析出的子结构（token 或子 AST）写入 AST 节点字段的过程；文章多次讨论“赋值发生的时机/对象是谁”这一核心问题。
- **Stack（栈）**：后进先出数据结构。解析器常用栈记录状态、递归上下文或语义动作需要的临时对象；文章中有 Create/Object 等多种栈。

## 递归、歧义与恢复

- **Left Recursion（左递归）**：产生式右侧以自身开头（直接或间接），会影响自顶向下解析与某些构造 AST 的策略。文章中多次围绕“左递归与指令时序冲突”展开。
- **Indirect Left Recursion（间接左递归）**：通过多条规则形成循环导致的左递归（如 A→B→…→A）。
- **Dangling Else（if-else 歧义）**：经典歧义：`else` 应该匹配最近的 `if` 还是更外层的 `if`；常用于讲解局部歧义处理与语法设计。
- **Ambiguity（歧义）**：同一输入存在多种合法推导/解析结果。文章关注“局部歧义”：不把它展开成多棵 AST，而是以结构记录“这里有分支”。
- **Local Ambiguity（局部歧义）**：把歧义限制在某个范围内表达（例如以共享结构记录分叉与合并），避免组合爆炸。
- **Error Recovery（自动恢复）**：解析器在遇到错误输入时尝试跳过/插入符号以继续解析，便于 IDE 场景（语义着色、自动完成）在不完整代码上工作。

## 文章中的关键内部概念

- **Trace（解析轨迹）**：文章中用于表示 PDA 执行过程的结构，后续步骤在 Trace 上分析歧义边界并生成可执行的指令序列。
- **Partial Execution（部分执行）**：在 Trace 上对指令做“只执行一部分/只算出需要的关系”的分析步骤，用来推导对象关系、歧义范围等信息。
- **ExecutionStep**：文章中对“可执行步骤”的抽象表示：先以树形结构构造，再整理为链表，以表达分支（BRANCH）与合并（RESOLVE）等控制流。
- **StackBegin / StackEnd 指令集**：为解决 BeginObject 指令集在复杂歧义/左递归下的扭曲补丁，引入的更底层、更结构化的指令体系，用显式 scope 边界来表达对象/字段/复用关系。
- **Reuse（复用）**：文章中用于描述“某些记录/字段最终指向同一 AST 对象”的关系，影响 StackBegin/StackEnd 边界推导。
- **Prefix Merge（前缀合并）**：当多条规则共享输入前缀时，在状态机/指令层面合并以减少状态机规模或避免重复处理；文章中以 `!prefix_merge` 形式出现。
- **Qualified Identifier（限定名）**：带作用域/命名空间前缀的标识符（如 `a::b::c`），在 C++ 等语言里会带来“类型/表达式/模板”等多重解析可能，是歧义处理的典型来源。
- **Start Set（起始集合）**：文章中用来描述某个 rule 可能从哪些“起始元素”开始（可理解为与 FIRST 集合相近的概念），用于排序与歧义定位。

## 工程化与算法

- **Serialization / Deserialization（序列化/反序列化）**：把内存中的状态机或结构编码成可存储/可嵌入的形式，再在运行时恢复；文章用它讨论“状态机尺寸”与工程实现代价。
- **Cache Friendly（缓存友好）**：数据布局/访问方式更贴近 CPU cache 的工作模式，减少缓存未命中；文章用来形容不同状态机存储方式的性能差异。
- **LZW（Lempel–Ziv–Welch）压缩**：无损压缩算法，常用于把重复子串编码为字典引用；文章用它把大型状态机压缩到可接受尺寸。
- **Kosaraju–Sharir Algorithm（Kosaraju–Sharir 算法）**：求有向图强连通分量（SCC）的经典算法；在分析 rule 依赖图、检测（间接）左递归、形成偏序关系时可用。
- **Bootstrapping（自举）**：用编译器/生成器的“产物”去构建它自身（例如用解析器生成器生成生成器所需的解析器），常见于编译器与工具链。

## 语言、工具与库（文中出现）

- **GLR Parser（Generalized LR Parser）**：能处理任意上下文无关文法（包括歧义文法）的 LR 系列扩展解析算法，通常通过“分支/合并”表达多种解析路径。
- **Parser Generator（解析器生成器）**：把文法、词法与 AST 定义编译成可执行解析器代码的工具（文中对应 `GlrParserGen.exe` 与 VlppParser2 的生成流程）。
- **IDE（集成开发环境）**：提供编辑、语法高亮、补全、调试等功能的开发工具；文章强调 IDE 场景需要在不完整代码上运行解析器。
- **Type Inference（类型推导）**：根据程序表达式结构自动推断类型（文中提及 Haskell 子集与类型推导）。
- **Type Class（类型类）**：Haskell 的重要抽象机制，用于对类型约束与多态行为建模；文章提到将其概念引入到其它语言的尝试。
- **GacUI / VlppParser / VlppParser2 / VlppRegex**：文中项目/库名，分别涉及 UI 框架与（词法/语法/AST）解析工具链实现。
